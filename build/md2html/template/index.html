<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>markdown to html</title>
    <link rel="stylesheet" href="./index.css">
</head>
<body>
    <pre><code class="language-javascript">//解释一下:
 const a = { 
    current:1, 
    valueOf () {
        return this.current++;
    }
}

if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {
    console.log(true) //true
}
</code></pre>
<p>这是一个利用<strong>类型转换 + 副作用</strong>的小把戏。</p>
<h3>发生了什么？</h3>
<p><em>当对象参与相等（==）比较时，JavaScript 会尝试将对象转换为原始数据类型。而在这个过程中，JavaScript 会先调用该对象的 <a href="">Symbol.toPrimitive</a>()方法，如果</em>返回结果不是原始数据类型，则JavaScript 会调用该对象的 valueOf()，如果方法的返回结果不是原始数据类型，则调用该对象的 toString() 方法，如果返回的结果是原始数据类型，则直接返回该值 </p>
<ul>
<li><code>==</code> 是<strong>宽松相等</strong>。当一边是对象（<code>a</code>）一边是原始值（<code>1/2/3</code>）时，JS 会把对象做 <strong>ToPrimitive</strong> 转换：<br>依次尝试 <code>a[Symbol.toPrimitive]</code> → <code>a.valueOf()</code> → <code>a.toString()</code>，直到得到一个原始值（number/string）。</li>
<li>你的 <code>a.valueOf()</code> 返回 <code>this.current++</code>，也就是<strong>先返回当前值，再把 <code>current</code> 自增</strong>。</li>
</ul>
<h3>按顺序求值（<code>&amp;&amp;</code> 从左到右，且短路）：</h3>
<p>初始：<code>a.current = 1</code></p>
<ol>
<li><p><code>a == 1</code></p>
<ul>
<li>调用 <code>a.valueOf()</code> → 返回 <code>1</code>，然后 <code>current</code> 变成 <code>2</code></li>
<li>比较 <code>1 == 1</code> → <code>true</code></li>
</ul>
</li>
<li><p><code>a == 2</code>（只有上一步为真才会继续）</p>
<ul>
<li>再次调用 <code>valueOf()</code> → 返回 <code>2</code>，<code>current</code> 变成 <code>3</code></li>
<li><code>2 == 2</code> → <code>true</code></li>
</ul>
</li>
<li><p><code>a == 3</code></p>
<ul>
<li>再次调用 <code>valueOf()</code> → 返回 <code>3</code>，<code>current</code> 变成 <code>4</code></li>
<li><code>3 == 3</code> → <code>true</code></li>
</ul>
</li>
</ol>
<p>三个都为真，所以进入 <code>if</code>，打印 <code>true</code>。</p>
<h3>关键点</h3>
<ul>
<li><strong>每次比较都会再次触发 <code>valueOf()</code></strong>，而 <code>valueOf()</code> 有<strong>副作用</strong>（<code>current++</code>），让返回值依次变成 1、2、3。</li>
<li>如果用 <code>===</code>（<strong>严格相等</strong>），不会触发对象到原始值的自动转换（或转换后也不相等），所以表达式为 <code>false</code>。</li>
<li>这是个 <strong>面试/趣味题</strong>，实际代码中是<strong>反模式</strong>：可读性差、易踩坑。</li>
</ul>
<h3>同类写法（更“正宗”的钩子）</h3>
<p>也可以用 <code>Symbol.toPrimitive</code> 明确指定转原始值逻辑：</p>
<pre><code>const a = {
  current: 1,
  [Symbol.toPrimitive](hint) {
    return this.current++;
  }
};
if(a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3) {
    console.log(true) //true
}
</code></pre>
<h2><strong>其他问题：</strong></h2>
<h4>1.为什么 return this.current++; 是先返回的current的值，然后在自加</h4>
<p>因为这是<strong>后置自增运算符</strong>（postfix increment）的语义：<code>expr++</code> 的<strong>表达式值</strong>是“自增之前的旧值”，但在求值过程中会把变量<strong>写回</strong>为“旧值 + 1”。</p>
<p>把 <code>return this.current++;</code> 按规范拆成步骤更清楚（精简版）：</p>
<ol>
<li>读取 <code>this.current</code> 的当前值，记为 <code>old</code>。</li>
<li>做数字化（<code>ToNumeric</code>/<code>ToNumber</code>），计算 <code>new = old + 1</code>。</li>
<li>把 <code>new</code> 写回 <code>this.current</code>。</li>
<li>整个表达式 <code>this.current++</code> 的<strong>结果值</strong>是 <code>old</code>。</li>
<li><code>return</code> 把这个<strong>结果值</strong>返回出去。</li>
</ol>
<p>所以它<strong>先返回旧值</strong>，但<strong>副作用</strong>是把 <code>current</code> 增加了 1。对比：</p>
<pre><code class="language-javascript">let x = 1;
console.log(x++, x); // 输出: 1 2   （先用1做结果，再把x改成2）
</code></pre>
<p>而前置自增 <code>++expr</code> 的规则是：先加再用值：</p>
<pre><code class="language-javascript">let y = 1;
console.log(++y, y); // 输出: 2 2   （先把y改成2，再用2做结果）
</code></pre>
<p>应用到你的例子里，每次比较都会调用 <code>valueOf()</code>，<code>return this.current++</code> 每次返回旧值（1、2、3…），同时把 <code>current</code> 往上加 1。</p>
<h4>2.JavaScript 一共有 <strong>7 种原始（primitive）数据类型</strong>，它们都是<strong>不可变值</strong>：</h4>
<ol>
<li><strong>number</strong>：数字（含 <code>NaN</code>、<code>Infinity</code>、<code>-Infinity</code> 都属于 number）</li>
<li><strong>string</strong>：字符串</li>
<li><strong>boolean</strong>：布尔值 <code>true</code> / <code>false</code></li>
<li><strong>null</strong>：空值（注意：<code>typeof null === &#39;object&#39;</code> 是历史遗留“坑”）</li>
<li><strong>undefined</strong>：未定义</li>
<li><strong>symbol</strong>：唯一的标识符（ES6）</li>
<li><strong>bigint</strong>：任意精度整数（ES2020），如 <code>123n</code></li>
</ol>
<p>补充要点：</p>
<ul>
<li><p><strong>原始值与对象不同</strong>：原始值不可变、按值比较；对象是可变的、按引用比较。</p>
</li>
<li><p><strong>包装对象</strong>：<code>new Number(1)</code>、<code>new String(&#39;a&#39;)</code>、<code>new Boolean(true)</code> 是对象，不是原始值；一般不要用。</p>
</li>
<li><p>常见 <code>typeof</code> 结果：</p>
<ul>
<li><code>typeof 1 === &#39;number&#39;</code></li>
<li><code>typeof &#39;a&#39; === &#39;string&#39;</code></li>
<li><code>typeof true === &#39;boolean&#39;</code></li>
<li><code>typeof undefined === &#39;undefined&#39;</code></li>
<li><code>typeof Symbol() === &#39;symbol&#39;</code></li>
<li><code>typeof 1n === &#39;bigint&#39;</code></li>
<li><code>typeof null === &#39;object&#39;</code> ← 历史问题，记住即可。</li>
</ul>
</li>
</ul>
<h4>3.js中什么是表达式</h4>
<p><strong>表达式（expression）就是能被求值并产生一个值</strong>的代码片段。只要一段代码放到需要“一个值”的地方能工作（比如赋值右侧、函数参数里、<code>return</code> 后面），它就是表达式。</p>
<h5>快速判断口诀</h5>
<blockquote>
<p><strong>能产生值 = 表达式；只做事不产值 = 语句（statement）</strong><br>如果这段代码能放到 <code>x = (这里);</code> 或 <code>console.log(这里)</code> 里，多半就是表达式。</p>
</blockquote>
<h5>常见表达式类型与例子</h5>
<ul>
<li><strong>字面量</strong>：<code>1</code>, <code>&#39;hi&#39;</code>, <code>true</code>, <code>null</code>, <code>undefined</code>, <code>Symbol()</code>, <code>123n</code></li>
<li><strong>标识符引用</strong>：<code>x</code>, <code>user.name</code>, <code>arr[0]</code></li>
<li><strong>运算符表达式</strong>：<code>a + b</code>, <code>x * 2</code>, <code>!ok</code>, <code>a &amp;&amp; b</code>, <code>a ? b : c</code></li>
<li><strong>赋值表达式</strong>（有返回值！）：<code>x = 1</code>, <code>a += 2</code>, <code>[x, y] = [y, x]</code></li>
<li><strong>函数调用</strong>：<code>fn()</code>, <code>Math.max(1,2)</code></li>
<li><strong><code>new</code> 表达式</strong>：<code>new Date()</code></li>
<li><strong>函数/类表达式</strong>：<code>(function(){})</code>, <code>() =&gt; 42</code>, <code>(class { })</code></li>
<li><strong>模板字符串中的插值</strong>： <code>`Hello ${name}`</code>（花括号内是表达式）</li>
<li><strong><code>await</code>/<code>yield</code> 表达式</strong>：<code>await fetch(url)</code>（在各自可用的上下文里）</li>
</ul>
<h5>语句 vs 表达式（对比）</h5>
<ul>
<li>语句例子：<code>if (...) {}</code>, <code>for (...) {}</code>, <code>while (...) {}</code>, <code>return ...;</code>, <code>break;</code>, <code>import ...</code></li>
<li>有些语句可以<strong>以“表达式语句”形式</strong>单独出现：<br>比如 <code>a = 1;</code>、<code>fn();</code>、<code>i++;</code>——它们本质是表达式，但被当作一整条语句来写。</li>
<li><strong>声明</strong>一般不是表达式：<code>let x = 1;</code>（这是“声明语句”，不是表达式）、<code>function foo(){}</code>（函数声明），<code>class Foo {}</code>（类声明）。<br>对应的<strong>函数表达式/类表达式</strong>才是表达式：<code>const foo = function(){}</code>、<code>const C = class {}</code>。</li>
</ul>
<h5>常见易混淆点</h5>
<ul>
<li><code>a = b = 3</code>：赋值表达式<strong>自右向左</strong>求值，并且<strong>返回被赋的值</strong>，所以整个结果是 <code>3</code>，同时 <code>a</code>、<code>b</code> 都变成 <code>3</code>。</li>
<li><code>a &amp;&amp; b</code>、<code>a || b</code> 有<strong>短路</strong>与<strong>返回操作数本身</strong>的语义（不一定是布尔值）。</li>
<li><code>,</code>（逗号）运算符也是表达式：<code>(expr1, expr2)</code> 的值是 <strong>最后一个表达式</strong>的值。</li>
<li><code>delete obj.x</code>、<code>typeof x</code>、<code>void 0</code> 都是表达式。</li>
</ul>
<p><strong>一句话总结</strong></p>
<blockquote>
<p><strong>表达式 = 会“算出一个值”的代码</strong>；<br><strong>语句 = 控制流程或做结构性的事</strong>。<br>在 JS 里，很多“能做事”的东西同时也是表达式（比如赋值、函数调用），这让写法很灵活。</p>
</blockquote>

</body>
</html>
